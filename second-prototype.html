<!DOCTYPE html>
<html>
<head>
  <title>SpellPop Game</title>
  <style>
    body {
      background-color: #05080a;
      color: #00FF00;
      font-family: monospace;
      overflow: hidden;
      margin: 0;
    }
    canvas {
      display: block;
      position: absolute;
      left: 0; top: 0;
      width: 100vw; height: 100vh;
      z-index: 0;
    }
    #scoreboard {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      color: #00FF00;
      font-size: 20px;
      text-shadow: 0 0 10px #00FF00;
      z-index: 2;
      pointer-events: none;
    }
    #inputBox {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      background: #111;
      color: #00FF00;
      font-family: monospace;
      border: 1px solid #00FF00;
      font-size: 20px;
      padding: 5px 10px;
      outline: none;
      z-index: 2;
      width: 320px;
      text-align: center;
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <audio id="popSound" src="pop.mp3" preload="auto"></audio>
  <audio id="eggSound" src="egg.mp3" preload="auto"></audio>
  <div id="scoreboard"></div>
  <input id="inputBox" autocomplete="off" spellcheck="false" placeholder="Type correct spelling to pop!"/>
  <script type="text/javascript">
    // ========== CANVAS & SETUP ==========
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    // Responsive canvas
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    const scoreboard = document.getElementById("scoreboard");
    const inputBox = document.getElementById("inputBox");
    const popSound = document.getElementById("popSound");
    const eggSound = document.getElementById("eggSound");

    // ========== GAME DATA ==========
    const bubbleRadius = 40;
    const flareSpeed = 6;
    const flareRadius = 5;
    const scopeRadius = 20;
    const bubbles = [];
    const correctWords = new Set();
    let wordTypos = {};  // word -> [typo, typo,...]
    let expertMode = false;
    let flares = [];
    let score = 0;
    let highScore = 10;
    let wordlist = [];
    let expertWordlist = [];
    let stars = [];

    const scope = {
      x: window.innerWidth / 2,
      y: window.innerHeight / 2,
      speed: 5
    };

    // ========== STARS ==========
    function createStars(count = 120) {
      stars = [];
      for (let i = 0; i < count; ++i) {
        stars.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          r: Math.random() * 1.5 + 0.3,
          a: Math.random() * 2 * Math.PI,
          tw: Math.random() * 0.02 + 0.005,
        });
      }
    }
    createStars();

    // ========== WORDLIST LOADING ==========
    function fetchWordlist(url, assignTo) {
      return fetch(url)
        .then(response => response.text())
        .then(data => {
          const arr = data.split("\n").map(w => w.trim()).filter(w => w.length > 0);
          if (assignTo === "wordlist") wordlist = arr;
          else if (assignTo === "expertWordlist") expertWordlist = arr;
          return arr;
        });
    }
    Promise.all([
      fetchWordlist("wordlist.txt", "wordlist"),
      fetchWordlist("expert-wordlist.txt", "expertWordlist")
    ]).then(initGame);

    // ========== TYPO GENERATOR ==========
    function generateTypos(word) {
      const qwertyNear = {
        a: "qwsz", b: "vghn", c: "xdfv", d: "ersfcx",
        e: "wsdr", f: "rtgvcd", g: "tyhbvf", h: "yujnbg",
        i: "ujko", j: "uikmnh", k: "ijolm", l: "opk",
        m: "njk", n: "bhjm", o: "iklp", p: "ol",
        q: "wa", r: "edft", s: "wedxz", t: "rfgy",
        u: "yhji", v: "cfgb", w: "qase", x: "zsdc",
        y: "tghu", z: "asx"
      };
      const typos = new Set();
      while (typos.size < 6 && word.length > 1) {
        const i = Math.floor(Math.random() * word.length);
        const ch = word[i].toLowerCase();
        if (qwertyNear[ch]) {
          const wrong = qwertyNear[ch][Math.floor(Math.random() * qwertyNear[ch].length)];
          const typo = word.slice(0, i) + wrong + word.slice(i + 1);
          if (typo !== word) typos.add(typo);
        }
      }
      return Array.from(typos);
    }

    // ========== BUBBLES & INIT ==========
    function spawnBubble(word, correct = false) {
      bubbles.push({
        word,
        correct,
        x: Math.random() * (canvas.width - 2 * bubbleRadius) + bubbleRadius,
        y: Math.random() * (canvas.height - 2 * bubbleRadius) + bubbleRadius,
        vx: (Math.random() - 0.5) * 2,
        vy: (Math.random() - 0.5) * 2,
        alpha: 1
      });
    }

    function resetGame() {
      bubbles.length = 0;
      correctWords.clear();
      wordTypos = {};
      score = 0;
      expertMode = false;
      flares = [];
      inputBox.value = "";
      createStars();
    }

    function initGame() {
      resetGame();
      let wl = expertMode ? expertWordlist : wordlist;
      for (let i = 0; i < 10; i++) {
        const word = wl[Math.floor(Math.random() * wl.length)];
        correctWords.add(word);
        spawnBubble(word, true);
        let typos = generateTypos(word);
        wordTypos[word] = typos;
        typos.forEach(typo => spawnBubble(typo, false));
      }
      inputBox.style.display = "block";
      inputBox.value = "";
      inputBox.blur();
    }

    // ========== DRAWING ROUTINES ==========
    function drawStars() {
      for (let star of stars) {
        ctx.save();
        ctx.globalAlpha = 0.7 + 0.3 * Math.sin(performance.now() * star.tw + star.a);
        ctx.beginPath();
        ctx.arc(star.x, star.y, star.r, 0, 2 * Math.PI);
        ctx.fillStyle = "#fff";
        ctx.fill();
        ctx.restore();
      }
    }

    function drawBubble(b) {
      ctx.save();
      ctx.globalAlpha = b.alpha;
      ctx.beginPath();
      ctx.arc(b.x, b.y, bubbleRadius, 0, Math.PI * 2);
      ctx.strokeStyle = b.correct ? "#00FF00" : "#00FF77";
      ctx.shadowColor = b.correct ? "#00FF00" : "#00FF77";
      ctx.shadowBlur = 10;
      ctx.stroke();
      ctx.fillStyle = b.correct ? "#021c03" : "#130013";
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
      ctx.fillStyle = b.correct ? "#00FF00" : "#FF55FF";
      ctx.font = "16px monospace";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(b.word, b.x, b.y);
      ctx.restore();
    }

    function drawScope() {
      ctx.save();
      ctx.beginPath();
      ctx.arc(scope.x, scope.y, scopeRadius, 0, Math.PI * 2);
      ctx.strokeStyle = "#00FF00";
      ctx.shadowColor = "#00FF00";
      ctx.shadowBlur = 8;
      ctx.stroke();
      // crosshairs
      ctx.beginPath();
      ctx.moveTo(scope.x - scopeRadius, scope.y);
      ctx.lineTo(scope.x + scopeRadius, scope.y);
      ctx.moveTo(scope.x, scope.y - scopeRadius);
      ctx.lineTo(scope.x, scope.y + scopeRadius);
      ctx.stroke();
      ctx.restore();
    }

    function drawFlare(f) {
      ctx.save();
      ctx.beginPath();
      ctx.arc(f.x, f.y, flareRadius, 0, Math.PI * 2);
      ctx.fillStyle = "#00FF00";
      ctx.shadowColor = "#00FF00";
      ctx.shadowBlur = 14;
      ctx.fill();
      ctx.restore();
    }

    // ========== GAME LOOP ==========
    function update() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawStars();

      // move and draw bubbles
      for (const b of bubbles) {
        b.x += b.vx;
        b.y += b.vy;
        if (b.x < bubbleRadius || b.x > canvas.width - bubbleRadius) b.vx *= -1;
        if (b.y < bubbleRadius || b.y > canvas.height - bubbleRadius) b.vy *= -1;
        drawBubble(b);
      }

      // move and draw flares
      for (let i = flares.length - 1; i >= 0; i--) {
        const f = flares[i];
        f.y -= flareSpeed;
        drawFlare(f);

        // check for collision with typo bubbles
        for (let j = bubbles.length - 1; j >= 0; j--) {
          const b = bubbles[j];
          if (b.correct) continue;
          const dx = b.x - f.x, dy = b.y - f.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < bubbleRadius) {
            popSound.play();
            bubbles.splice(j, 1);
            flares.splice(i, 1);
            score++;
            break;
          }
        }
      }

      // update scoreboard
      scoreboard.innerText = `Score: ${score}   High Score: ${highScore}` + (expertMode ? " [EXPERT]" : "");

      // draw scope
      drawScope();

      requestAnimationFrame(update);
    }

    // ========== INPUT HANDLING ==========
    // Typing correct spelling: clears typo bubbles for that word
    inputBox.addEventListener("keydown", function(e) {
      if (e.key === "Enter" && inputBox.value) {
        const val = inputBox.value.trim();
        if (correctWords.has(val)) {
          // Remove ALL typo bubbles for this word, keep the correct one
          let typos = wordTypos[val] || [];
          let removed = 0;
          for (let i = bubbles.length - 1; i >= 0; --i) {
            if (!bubbles[i].correct && typos.includes(bubbles[i].word)) {
              bubbles.splice(i, 1);
              removed++;
              score++;
            }
          }
          if (removed > 0) eggSound.play();
          inputBox.value = "";
          if (score > highScore && !expertMode) {
            expertMode = true;
            highScore = score;
            setTimeout(()=>initGame(), 500);
            return;
          }
        } else {
          inputBox.value = "";
        }
      }
    });

    // Clicking typo bubbles: pop them
    canvas.addEventListener("mousedown", function(e) {
      const rect = canvas.getBoundingClientRect();
      const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
      const my = (e.clientY - rect.top) * (canvas.height / rect.height);
      for (let i = bubbles.length - 1; i >= 0; --i) {
        const b = bubbles[i];
        if (!b.correct) {
          const dx = b.x - mx, dy = b.y - my;
          if (dx * dx + dy * dy < bubbleRadius * bubbleRadius) {
            bubbles.splice(i, 1);
            popSound.play();
            score++;
            break;
          }
        }
      }
    });

    // Scope movement & flare shooting
    document.addEventListener("keydown", e => {
      if (inputBox === document.activeElement) return;
      if (e.key === "ArrowLeft") scope.x = Math.max(scope.x - scope.speed, scopeRadius);
      if (e.key === "ArrowRight") scope.x = Math.min(scope.x + scope.speed, canvas.width - scopeRadius);
      if (e.key === "ArrowUp") scope.y = Math.max(scope.y - scope.speed, scopeRadius);
      if (e.key === "ArrowDown") scope.y = Math.min(scope.y + scope.speed, canvas.height - scopeRadius);
      if (e.key === " ") {
        flares.push({ x: scope.x, y: scope.y });
      }
      if (/^[a-zA-Z]$/.test(e.key)) {
        inputBox.style.display = "block";
        inputBox.focus();
      }
      if (e.key === "r") {
        initGame();
      }
    });

    // ========== INIT ==========
    inputBox.style.display = "block";
    inputBox.blur();
    update();
  </script>
</body>
</html>
